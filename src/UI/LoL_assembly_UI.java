/*******************************************************************************
*   Project: LoL Assembler
*
*   File: LoL_assembly_UI.java
*
*   Description: @TODO
*
*   Notes: N/A
*
*   Contact: Alberto Martin Cajal, amartin.glimpse23<AT>gmail.com
*
*   URL: https://github.com/amcajal/lol_assembler
*
*   License: GNU GPL v3.0
*
*   Copyright (C) 2018 Alberto Martin Cajal
*
*   This file is part of LoL Assembler project.
*
*   LoL Assembler is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   LoL Assembler is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*******************************************************************************/


package UI;

// IMPORT THE SOURCE CODE CLASSES
import SourceCode.*;
import java.awt.Color;
import java.awt.Image;
import java.awt.Insets;
//import java.io.File;
//import java.awt.Toolkit;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.net.MalformedURLException;
import java.util.LinkedHashMap;
import java.util.logging.Level;
import java.util.logging.Logger;
//import javax.swing.JFrame;
import javax.imageio.ImageIO;
import javax.swing.JOptionPane;
import javax.swing.border.EmptyBorder;

/**
 *
 * @author Alberto
 */
public class LoL_assembly_UI extends javax.swing.JFrame {

    // HERE IS WHERE THE CLASSES ARE DECLARED
    Path path;
    Downloader downloader;
    Flags fileType;
    FileWorker fileWorker;
    FileStatus fileStatus;
    Information information;
    
    Color bgc, originalB, originalF;

    /** Creates new form LoL_assembly_UI */
    public LoL_assembly_UI() {
        initComponents();

        Image i;
        try {
            i = ImageIO.read(getClass().getResource("/Images/lol_assembler_icon.png"));
            setIconImage(i);
        } catch (IOException ex) {
            Logger.getLogger(LoL_assembly_UI.class.getName()).log(Level.SEVERE, null, ex);
        }
 
        bgc = new Color(5,23,37);
        getContentPane().setBackground(bgc);
        originalB = updateButton.getBackground();
        originalF = updateButton.getForeground();

        this.setTitle ("LoL Assembler - Tool for strategic picks in League of Legends (R) game");
        
        mainTextArea.setMargin(new Insets(15,25,25,25)); // Apply margins
        mainTextArea.setEditable(false);
        
        // HERE IS WHERE THE CLASSES ARE INITIALIZED
        try {
            path = new Path();
            downloader = new Downloader(path.getDownloadList() ,path.getDownloadSite());
            fileType = null;
            fileWorker = new FileWorker(path.getMainPath());
            fileStatus = new FileStatus();
            information = new Information();

            /*
            this.mainTextArea.setText(this.mainTextArea.getText() +
            "--------------------------------------------------------------------------" + "\n" +
            "       LOL ASSEMBLER: The support tool for strategy picks." + "\n"
                    +"      Please CHECK for errors or new versions before play. " + "\n" +
            "--------------------------------------------------------------------------" + "\n");
             * 
             */

            this.mainTextArea.setText(this.mainTextArea.getText() +
            "--------------------------------------------------------------------------" + 
                    "-----------------------\n" +
            "           Press CHECK for errors or new versions before play " + "\n" +
            "--------------------------------------------------------------------------" + 
                    "-----------------------\n");

            setDefaultCloseOperation(LoL_assembly_UI.EXIT_ON_CLOSE);
        }
        catch (MalformedURLException ex1) {
            System.err.println("Malformed URL Exception: " + ex1.getMessage());
        }
        finally {
            //System.err.println("The program ended with errors");
        }

    }

    /*
    @Override
    public Image getIconImage() {
	Image retValue= Toolkit.getDefaultToolkit().getImage(ClassLoader.getSystemResource("Images/lol_assembler_icon.png"));
	return retValue;
    }
     *
     */

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        mainTextArea = new javax.swing.JTextArea();
        checkButton = new javax.swing.JButton();
        updateButton = new javax.swing.JButton();
        exitButton = new javax.swing.JButton();
        rankedButton = new javax.swing.JButton();
        normalButton = new javax.swing.JButton();
        informationButton = new javax.swing.JButton();
        modifyButton = new javax.swing.JButton();
        licenseButton = new javax.swing.JButton();
        aboutButton = new javax.swing.JButton();
        configurationButton = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jPanel1.setBackground(new java.awt.Color(5, 23, 37));

        mainTextArea.setBackground(new java.awt.Color(39, 40, 34));
        mainTextArea.setColumns(20);
        mainTextArea.setForeground(new java.awt.Color(255, 255, 0));
        mainTextArea.setRows(5);
        mainTextArea.setBorder (new EmptyBorder(10, 10, 10, 10) );
        jScrollPane1.setViewportView(mainTextArea);

        checkButton.setBackground(new java.awt.Color(255, 255, 0));
        checkButton.setFont(new java.awt.Font("Tahoma", 1, 11));
        checkButton.setText("Check !!!");
        checkButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkButtonActionPerformed(evt);
            }
        });

        updateButton.setBackground(new java.awt.Color(54, 109, 90));
        updateButton.setFont(new java.awt.Font("Tahoma", 1, 11));
        updateButton.setForeground(new java.awt.Color(255, 255, 255));
        updateButton.setText("Update");
        updateButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                updateButtonActionPerformed(evt);
            }
        });

        exitButton.setBackground(new java.awt.Color(30, 68, 116));
        exitButton.setFont(new java.awt.Font("Tahoma", 1, 11));
        exitButton.setForeground(new java.awt.Color(255, 255, 255));
        exitButton.setText("Exit");
        exitButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                exitButtonActionPerformed(evt);
            }
        });

        rankedButton.setBackground(new java.awt.Color(184, 8, 12));
        rankedButton.setFont(new java.awt.Font("Tahoma", 1, 11));
        rankedButton.setForeground(new java.awt.Color(255, 255, 255));
        rankedButton.setText("Ranked");
        rankedButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rankedButtonActionPerformed(evt);
            }
        });

        normalButton.setBackground(new java.awt.Color(184, 8, 12));
        normalButton.setFont(new java.awt.Font("Tahoma", 1, 11));
        normalButton.setForeground(new java.awt.Color(255, 255, 255));
        normalButton.setText("Normal");
        normalButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                normalButtonActionPerformed(evt);
            }
        });

        informationButton.setBackground(new java.awt.Color(184, 8, 12));
        informationButton.setFont(new java.awt.Font("Tahoma", 1, 11));
        informationButton.setForeground(new java.awt.Color(255, 255, 255));
        informationButton.setText("Information");
        informationButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                informationButtonActionPerformed(evt);
            }
        });

        modifyButton.setBackground(new java.awt.Color(54, 109, 90));
        modifyButton.setFont(new java.awt.Font("Tahoma", 1, 11));
        modifyButton.setForeground(new java.awt.Color(255, 255, 255));
        modifyButton.setText("Modify");
        modifyButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                modifyButtonActionPerformed(evt);
            }
        });

        licenseButton.setBackground(new java.awt.Color(30, 68, 116));
        licenseButton.setFont(new java.awt.Font("Tahoma", 1, 11));
        licenseButton.setForeground(new java.awt.Color(255, 255, 255));
        licenseButton.setText("License");
        licenseButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                licenseButtonActionPerformed(evt);
            }
        });

        aboutButton.setBackground(new java.awt.Color(30, 68, 116));
        aboutButton.setFont(new java.awt.Font("Tahoma", 1, 11));
        aboutButton.setForeground(new java.awt.Color(255, 255, 255));
        aboutButton.setText("About");
        aboutButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                aboutButtonActionPerformed(evt);
            }
        });

        configurationButton.setBackground(new java.awt.Color(54, 109, 90));
        configurationButton.setFont(new java.awt.Font("Tahoma", 1, 11));
        configurationButton.setForeground(new java.awt.Color(255, 255, 255));
        configurationButton.setText("Configuration");
        configurationButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                configurationButtonActionPerformed(evt);
            }
        });

        jLabel1.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel1.setIcon(new javax.swing.ImageIcon(getClass().getResource("/Images/lol_assembler_logo_27.png"))); // NOI18N

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(checkButton, javax.swing.GroupLayout.DEFAULT_SIZE, 111, Short.MAX_VALUE)
                    .addComponent(updateButton, javax.swing.GroupLayout.DEFAULT_SIZE, 111, Short.MAX_VALUE)
                    .addComponent(exitButton, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 111, Short.MAX_VALUE)
                    .addComponent(modifyButton, javax.swing.GroupLayout.DEFAULT_SIZE, 111, Short.MAX_VALUE)
                    .addComponent(normalButton, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 111, Short.MAX_VALUE)
                    .addComponent(rankedButton, javax.swing.GroupLayout.DEFAULT_SIZE, 111, Short.MAX_VALUE)
                    .addComponent(informationButton, javax.swing.GroupLayout.DEFAULT_SIZE, 111, Short.MAX_VALUE)
                    .addComponent(aboutButton, javax.swing.GroupLayout.DEFAULT_SIZE, 111, Short.MAX_VALUE)
                    .addComponent(licenseButton, javax.swing.GroupLayout.DEFAULT_SIZE, 111, Short.MAX_VALUE)
                    .addComponent(configurationButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGap(18, 18, 18)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jLabel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 501, Short.MAX_VALUE))
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(checkButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(updateButton)
                        .addGap(31, 31, 31))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(jLabel1, javax.swing.GroupLayout.DEFAULT_SIZE, 97, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)))
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 315, Short.MAX_VALUE)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(configurationButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(modifyButton)
                        .addGap(33, 33, 33)
                        .addComponent(informationButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(normalButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(rankedButton)
                        .addGap(33, 33, 33)
                        .addComponent(aboutButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(licenseButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 21, Short.MAX_VALUE)
                        .addComponent(exitButton)))
                .addContainerGap())
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void checkButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkButtonActionPerformed
        // TODO add your handling code here:
        try {
            this.mainTextArea.setText("Checking in process...\n");
            fileStatus.initialCheck(path, information.getTotalFiles(), information.getTotalPersonalFiles());
            this.mainTextArea.setText("");
            this.mainTextArea.setText(this.mainTextArea.getText() + fileStatus.getMessage());
            //this.mainTextArea.setText(fileStatus.getMessage());
            fileStatus.cleanMessage();
            downloader.downloadData(fileStatus, path.getMainPath() + path.getDownloadPath());
            if (fileStatus.getUpdateStatus()==true) { // The program need to be updated
                checkButton.setBackground(originalB);
                checkButton.setForeground(originalF);
                
                updateButton.setBackground(Color.yellow);
                updateButton.setForeground(Color.black);
                updateButton.setText("Update !!!");
            }
            else { // The program dont need to be updated
                checkButton.setBackground(originalB);
                checkButton.setForeground(originalF);
                checkButton.setText("Check");
            }
        }
        catch (IOException ex2) {
            Logger.getLogger(LoL_assembly_UI.class.getName()).log(Level.SEVERE, null, ex2);
            System.err.println("IO Exception: " + ex2.getMessage());
        }
        finally {
            //System.err.println("The program ended with errors");
        }
    }//GEN-LAST:event_checkButtonActionPerformed

    private void exitButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exitButtonActionPerformed
        // TODO add your handling code here:
        int selectedOption = JOptionPane.showConfirmDialog(null,
                                  "Do you want to exit the program?", // Message of the window
                                  "Exiting LOL Assembler", // Message of the header
                                  JOptionPane.YES_NO_OPTION);

        if (selectedOption == JOptionPane.YES_OPTION) {
            System.gc(); // Release all the resources
            System.exit(0);
        }
    }//GEN-LAST:event_exitButtonActionPerformed

    private void updateButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_updateButtonActionPerformed
        // TODO add your handling code here:
        int selectedOption = JOptionPane.showConfirmDialog(null,
                                  "This operation will take a few seconds. Continue?", // Message of the window
                                  "Update LoL Assembler", // Message of the header
                                  JOptionPane.YES_NO_OPTION);

        if (selectedOption == JOptionPane.YES_OPTION) {
            try {
                this.mainTextArea.setText ("");
                this.mainTextArea.setText(this.mainTextArea.getText() + 
                        "--------------------------------------------------------------------------" + "\n\n" +
                        " UPDATING DATA...\n\n");

                information.release(); // Release all previously loaded data
                fileWorker.clear();

                this.mainTextArea.setText(this.mainTextArea.getText() +
                        "       Cleaning and restoring directories..." + "\n");
                fileStatus.cleanAndCreate(path);
                this.mainTextArea.update(this.mainTextArea.getGraphics()); // UPDATE DATA IN THE UI

                // Read champion list and generate proper file
                this.mainTextArea.setText(this.mainTextArea.getText() +
                        "       Generating champion list file..." + "\n");
                this.mainTextArea.update(this.mainTextArea.getGraphics()); // UPDATE DATA IN THE UI
                
                downloader.downloadData(fileStatus, path.getMainPath() + path.getDownloadPath());
                path.setInputFile("data_html.txt"); // Fill through browser
                fileWorker.read(path.getMainPath() + path.getDownloadPath() + path.getInputFile(), fileType.LIST); // Now the data is inside fileWorker
                fileWorker.write(path.getMainPath() + path.getListPath() + path.getChampionListFile(), fileType.LIST, fileStatus);
                //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                //Read list and store it in the Information class, in the proper list
                path.setInputFile(path.getMainPath() + path.getListPath() + path.getChampionListFile());
                fileWorker.read(path.getInputFile(), fileType.MAP);
                information.loadData((LinkedHashMap<String, String>) fileWorker.load(fileType.LIST),
                    fileType.LIST); // Why the cast is mandatory?
                //fileWorker.clear(); // When the data is secured, then the maps can be cleaned ??????

                this.mainTextArea.setText(this.mainTextArea.getText() +
                        "       Generating counterpicks files..." + "\n");
                this.mainTextArea.update(this.mainTextArea.getGraphics()); // UPDATE DATA IN THE UI

                // Using the list of champions, download their counterpicks data
                //downloader.downloadData(fileStatus, path.getMainPath() + path.getDownloadPath(), information.getChampionList(), this.mainTextArea);

                /*
                this.mainTextArea.setText(this.mainTextArea.getText() +
                    "Generating counterpicks data files..."+ "\n");
                this.mainTextArea.update(this.mainTextArea.getGraphics()); // UPDATE DATA IN THE UI
                 */
                
                // THE PROCESSING OF ALL THE CHAMPION DATA IS PERFORMED HERE, CALLING TO "fileWorker.read" ANY NEEDED TIMES
                //File[] files = new File(path.getMainPath() + path.getDownloadPath()).listFiles();


                /*
                for (File file : files) {
                path.setInputFile(file.getName());
                fileWorker.read(path.getMainPath() + path.getDownloadPath() 
                        + path.getInputFile(), fileType.HTML);
                }
                 */

                // THE PROCESSING OF ALL THE CHAMPION DATA IS PERFORMED HERE, CALLING TO "fileWorker.read" ANY NEEDED TIMES
                path.setInputFile("data_html.txt");
                // STRONG
                fileWorker.read(path.getMainPath() + path.getDownloadPath()
                        + path.getInputFile(), fileType.STRONG);

                // WEAK
                fileWorker.read(path.getMainPath() + path.getDownloadPath()
                        + path.getInputFile(), fileType.WEAK);

                // EVEN
                fileWorker.read(path.getMainPath() + path.getDownloadPath()
                        + path.getInputFile(), fileType.EVEN);

                // WELL
                fileWorker.read(path.getMainPath() + path.getDownloadPath()
                        + path.getInputFile(), fileType.WELL);

                
                // At this moment, fileWorker has all the maps completed.
                // Store the information files                
                fileWorker.write(path.getMainPath() + path.getInformationPath() +
                    path.getStrongAgainstFile(), fileType.STRONG, fileStatus);

                fileWorker.write(path.getMainPath() + path.getInformationPath() +
                    path.getWeakAgainstFile(), fileType.WEAK, fileStatus);

                fileWorker.write(path.getMainPath() + path.getInformationPath() +
                    path.getEvenAgainstFile(), fileType.EVEN, fileStatus);

                fileWorker.write(path.getMainPath() + path.getInformationPath() +
                    path.getWorksWellFile(), fileType.WELL, fileStatus);

                //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                // Update "last update operation" date
                fileStatus.updateDate(path);

                this.mainTextArea.setText(this.mainTextArea.getText() +
                        "\n UPDATE FINISHED. PRESS CHECK TO VERIFY AGAIN"+ "\n\n" +
                        "--------------------------------------------------------------------------" + "\n");
                
                updateButton.setBackground(originalB);
                updateButton.setForeground(originalF);
                
                checkButton.setBackground(Color.yellow);
                checkButton.setForeground(Color.black);
                checkButton.setText("Check !!!");
                
            } catch (FileNotFoundException ex) {
                Logger.getLogger(LoL_assembly_UI.class.getName()).log(Level.SEVERE, null, ex);
            } catch (IOException ex) {
                Logger.getLogger(LoL_assembly_UI.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }//GEN-LAST:event_updateButtonActionPerformed

    private void rankedButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rankedButtonActionPerformed
        // TODO add your handling code here:
        if (this.fileStatus.getReady() == true){

            if (information.getLoaded() == false) {

                try {

                    information.setLoaded(true);
                    fileWorker.clear();

                    // This must be checked, because at the begining of the program, the champion list is not loaded
                    if (information.getChampionList().isEmpty()) {
                        path.setInputFile(path.getMainPath() + path.getListPath() + path.getChampionListFile());
                        fileWorker.read(path.getInputFile(), fileType.MAP);
                        information.loadData((LinkedHashMap<String, String>) fileWorker.load(fileType.LIST),
                        fileType.LIST); // Why the cast is mandatory?
                    }

                    // Now, call to information.loadData the required number of times
                    path.setInputFile(path.getMainPath() + path.getInformationPath() + path.getStrongAgainstFile());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.STRONG), fileType.STRONG); // Why the cast is mandatory?
                    //fileWorker.clear(); // In this point, the information is correctly load into Information class.

                    path.setInputFile(path.getMainPath() + path.getInformationPath() + path.getWeakAgainstFile());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.WEAK), fileType.WEAK); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    path.setInputFile(path.getMainPath() + path.getInformationPath() + path.getEvenAgainstFile());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.EVEN), fileType.EVEN); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    path.setInputFile(path.getMainPath() + path.getInformationPath() + path.getWorksWellFile());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.WELL), fileType.WELL); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned
                                        
                    path.setInputFile(path.getMainPath() + path.getPersonalPath() + path.getHotOnesFile());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.HOT), fileType.HOT); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned
                    
                    path.setInputFile(path.getMainPath() + path.getPersonalPath() + path.getLovedOnesFile());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.LOVED), fileType.LOVED); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned
                    
                    path.setInputFile(path.getMainPath() + path.getPersonalPath() + path.getHatedOnesFile());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.HATED), fileType.HATED); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned
                    
                    path.setInputFile(path.getMainPath() + path.getPersonalPath() + path.getPersonalCombosFile());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.COMBOS), fileType.COMBOS); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    path.setInputFile(path.getMainPath() + path.getPersonalPath() + path.getPersonalStrongAgainst());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.PSTRONG), fileType.PSTRONG); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    path.setInputFile(path.getMainPath() + path.getPersonalPath() + path.getPersonalWeakAgainst());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.PWEAK), fileType.PWEAK); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    path.setInputFile(path.getMainPath() + path.getPersonalPath() + path.getPersonalEvenAgainst());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.PEVEN), fileType.PEVEN); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    path.setInputFile(path.getMainPath() + path.getPersonalPath() + path.getPersonalWorksWell());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.PWELL), fileType.PWELL); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    // In this point, the information is correctly load into Information class.
                } catch (FileNotFoundException ex) {
                    Logger.getLogger(LoL_assembly_UI.class.getName()).log(Level.SEVERE, null, ex);
                } catch (IOException ex) {
                    Logger.getLogger(LoL_assembly_UI.class.getName()).log(Level.SEVERE, null, ex);
                }

            }

            Config_UI configUI = new Config_UI(information);
            configUI.setVisible (true);
        }
        else {
            this.mainTextArea.setText(this.mainTextArea.getText() +
            "--------------------------------------------------------------------------" + 
                    "-----------------------\n" +
            "           Press CHECK for errors or new versions before play " + "\n" +
            "--------------------------------------------------------------------------" + 
                    "-----------------------\n");
        }
        

    }//GEN-LAST:event_rankedButtonActionPerformed

    private void modifyButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_modifyButtonActionPerformed
        // TODO add your handling code here:
        if (this.fileStatus.getReady() == true){

            if (information.getLoaded() == false) {

                try {

                    information.setLoaded(true);
                    fileWorker.clear();

                    // This must be checked, because at the begining of the program, the champion list is not loaded
                    if (information.getChampionList().isEmpty()) {
                        path.setInputFile(path.getMainPath() + path.getListPath() + path.getChampionListFile());
                        fileWorker.read(path.getInputFile(), fileType.MAP);
                        information.loadData((LinkedHashMap<String, String>) fileWorker.load(fileType.LIST),
                        fileType.LIST); // Why the cast is mandatory?
                    }

                    // Now, call to information.loadData the required number of times
                    path.setInputFile(path.getMainPath() + path.getInformationPath() + path.getStrongAgainstFile());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.STRONG), fileType.STRONG); // Why the cast is mandatory?
                    //fileWorker.clear(); // In this point, the information is correctly load into Information class.

                    path.setInputFile(path.getMainPath() + path.getInformationPath() + path.getWeakAgainstFile());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.WEAK), fileType.WEAK); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    path.setInputFile(path.getMainPath() + path.getInformationPath() + path.getEvenAgainstFile());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.EVEN), fileType.EVEN); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    path.setInputFile(path.getMainPath() + path.getInformationPath() + path.getWorksWellFile());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.WELL), fileType.WELL); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    path.setInputFile(path.getMainPath() + path.getPersonalPath() + path.getHotOnesFile());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.HOT), fileType.HOT); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    path.setInputFile(path.getMainPath() + path.getPersonalPath() + path.getLovedOnesFile());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.LOVED), fileType.LOVED); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    path.setInputFile(path.getMainPath() + path.getPersonalPath() + path.getHatedOnesFile());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.HATED), fileType.HATED); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    path.setInputFile(path.getMainPath() + path.getPersonalPath() + path.getPersonalCombosFile());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.COMBOS), fileType.COMBOS); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    path.setInputFile(path.getMainPath() + path.getPersonalPath() + path.getPersonalStrongAgainst());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.PSTRONG), fileType.PSTRONG); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    path.setInputFile(path.getMainPath() + path.getPersonalPath() + path.getPersonalWeakAgainst());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.PWEAK), fileType.PWEAK); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    path.setInputFile(path.getMainPath() + path.getPersonalPath() + path.getPersonalEvenAgainst());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.PEVEN), fileType.PEVEN); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    path.setInputFile(path.getMainPath() + path.getPersonalPath() + path.getPersonalWorksWell());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.PWELL), fileType.PWELL); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    // In this point, the information is correctly load into Information class.
                } catch (FileNotFoundException ex) {
                    Logger.getLogger(LoL_assembly_UI.class.getName()).log(Level.SEVERE, null, ex);
                } catch (IOException ex) {
                    Logger.getLogger(LoL_assembly_UI.class.getName()).log(Level.SEVERE, null, ex);
                }

            }

            Modify_First_UI modifyFirstUI = new Modify_First_UI(information, path);
            modifyFirstUI.setVisible (true);
        }
        else {
            this.mainTextArea.setText(this.mainTextArea.getText() +
            "--------------------------------------------------------------------------" + 
                    "-----------------------\n" +
            "           Press CHECK for errors or new versions before play " + "\n" +
            "--------------------------------------------------------------------------" + 
                    "-----------------------\n");
        }
    }//GEN-LAST:event_modifyButtonActionPerformed

    private void normalButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_normalButtonActionPerformed
         if (this.fileStatus.getReady() == true){

            if (information.getLoaded() == false) {

                try {

                    information.setLoaded(true);
                    fileWorker.clear();

                    // This must be checked, because at the begining of the program, the champion list is not loaded
                    if (information.getChampionList().isEmpty()) {
                        path.setInputFile(path.getMainPath() + path.getListPath() + path.getChampionListFile());
                        fileWorker.read(path.getInputFile(), fileType.MAP);
                        information.loadData((LinkedHashMap<String, String>) fileWorker.load(fileType.LIST),
                        fileType.LIST); // Why the cast is mandatory?
                    }

                    // Now, call to information.loadData the required number of times
                    path.setInputFile(path.getMainPath() + path.getInformationPath() + path.getStrongAgainstFile());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.STRONG), fileType.STRONG); // Why the cast is mandatory?
                    //fileWorker.clear(); // In this point, the information is correctly load into Information class.

                    path.setInputFile(path.getMainPath() + path.getInformationPath() + path.getWeakAgainstFile());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.WEAK), fileType.WEAK); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    path.setInputFile(path.getMainPath() + path.getInformationPath() + path.getEvenAgainstFile());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.EVEN), fileType.EVEN); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    path.setInputFile(path.getMainPath() + path.getInformationPath() + path.getWorksWellFile());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.WELL), fileType.WELL); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    path.setInputFile(path.getMainPath() + path.getPersonalPath() + path.getHotOnesFile());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.HOT), fileType.HOT); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    path.setInputFile(path.getMainPath() + path.getPersonalPath() + path.getLovedOnesFile());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.LOVED), fileType.LOVED); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    path.setInputFile(path.getMainPath() + path.getPersonalPath() + path.getHatedOnesFile());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.HATED), fileType.HATED); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    path.setInputFile(path.getMainPath() + path.getPersonalPath() + path.getPersonalCombosFile());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.COMBOS), fileType.COMBOS); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    path.setInputFile(path.getMainPath() + path.getPersonalPath() + path.getPersonalStrongAgainst());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.PSTRONG), fileType.PSTRONG); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    path.setInputFile(path.getMainPath() + path.getPersonalPath() + path.getPersonalWeakAgainst());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.PWEAK), fileType.PWEAK); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    path.setInputFile(path.getMainPath() + path.getPersonalPath() + path.getPersonalEvenAgainst());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.PEVEN), fileType.PEVEN); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    path.setInputFile(path.getMainPath() + path.getPersonalPath() + path.getPersonalWorksWell());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.PWELL), fileType.PWELL); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    // In this point, the information is correctly load into Information class.
                } catch (FileNotFoundException ex) {
                    Logger.getLogger(LoL_assembly_UI.class.getName()).log(Level.SEVERE, null, ex);
                } catch (IOException ex) {
                    Logger.getLogger(LoL_assembly_UI.class.getName()).log(Level.SEVERE, null, ex);
                }

            }

            //Normal_UI normalUI = new Normal_UI (information);
            //normalUI.setVisible(true);
            Players_UI playersUI = new Players_UI (information);
            playersUI.setVisible(true);
        }
        else {
            this.mainTextArea.setText(this.mainTextArea.getText() +
            "--------------------------------------------------------------------------" + 
                    "-----------------------\n" +
            "           Press CHECK for errors or new versions before play " + "\n" +
            "--------------------------------------------------------------------------" + 
                    "-----------------------\n");
        }
    }//GEN-LAST:event_normalButtonActionPerformed

    private void aboutButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_aboutButtonActionPerformed
        // TODO add your handling code here:
        Meta_UI metaUI = new Meta_UI (this.fileType.ABOUT);
        metaUI.setVisible(true);
    }//GEN-LAST:event_aboutButtonActionPerformed

    private void licenseButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_licenseButtonActionPerformed
        // TODO add your handling code here:
        Meta_UI metaUI = new Meta_UI (this.fileType.LICENSE);
        metaUI.setVisible(true);
    }//GEN-LAST:event_licenseButtonActionPerformed

    private void informationButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_informationButtonActionPerformed
        if (this.fileStatus.getReady() == true){

            if (information.getLoaded() == false) {

                try {

                    information.setLoaded(true);
                    fileWorker.clear();

                    // This must be checked, because at the begining of the program, the champion list is not loaded
                    if (information.getChampionList().isEmpty()) {
                        path.setInputFile(path.getMainPath() + path.getListPath() + path.getChampionListFile());
                        fileWorker.read(path.getInputFile(), fileType.MAP);
                        information.loadData((LinkedHashMap<String, String>) 
                                fileWorker.load(fileType.LIST), fileType.LIST); // Why the cast is mandatory?
                        //fileWorker.clear();
                    }

                    // Now, call to information.loadData the required number of times
                    path.setInputFile(path.getMainPath() + path.getInformationPath() + path.getStrongAgainstFile());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.STRONG), fileType.STRONG); // Why the cast is mandatory?
                    //fileWorker.clear(); // In this point, the information is correctly load into Information class.
                    
                    path.setInputFile(path.getMainPath() + path.getInformationPath() + path.getWeakAgainstFile());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.WEAK), fileType.WEAK); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    path.setInputFile(path.getMainPath() + path.getInformationPath() + path.getEvenAgainstFile());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.EVEN), fileType.EVEN); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    path.setInputFile(path.getMainPath() + path.getInformationPath() + path.getWorksWellFile());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.WELL), fileType.WELL); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    path.setInputFile(path.getMainPath() + path.getPersonalPath() + path.getHotOnesFile());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.HOT), fileType.HOT); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    path.setInputFile(path.getMainPath() + path.getPersonalPath() + path.getLovedOnesFile());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.LOVED), fileType.LOVED); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    path.setInputFile(path.getMainPath() + path.getPersonalPath() + path.getHatedOnesFile());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.HATED), fileType.HATED); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    path.setInputFile(path.getMainPath() + path.getPersonalPath() + path.getPersonalCombosFile());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.COMBOS), fileType.COMBOS); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    path.setInputFile(path.getMainPath() + path.getPersonalPath() + path.getPersonalStrongAgainst());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.PSTRONG), fileType.PSTRONG); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    path.setInputFile(path.getMainPath() + path.getPersonalPath() + path.getPersonalWeakAgainst());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.PWEAK), fileType.PWEAK); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    path.setInputFile(path.getMainPath() + path.getPersonalPath() + path.getPersonalEvenAgainst());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.PEVEN), fileType.PEVEN); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    path.setInputFile(path.getMainPath() + path.getPersonalPath() + path.getPersonalWorksWell());
                    fileWorker.read(path.getInputFile(), fileType.MAP);
                    information.loadData((LinkedHashMap<String, String>)
                            fileWorker.load(fileType.PWELL), fileType.PWELL); // Why the cast is mandatory?
                    //fileWorker.clear(); // When the data is secured, then the maps can be cleaned

                    // In this point, the information is correctly load into Information class.
                } catch (FileNotFoundException ex) {
                    Logger.getLogger(LoL_assembly_UI.class.getName()).log(Level.SEVERE, null, ex);
                } catch (IOException ex) {
                    Logger.getLogger(LoL_assembly_UI.class.getName()).log(Level.SEVERE, null, ex);
                }

            }
            
            Info_UI infoUI = new Info_UI(information);
            infoUI.setVisible (true);
        }
        else {
            this.mainTextArea.setText(this.mainTextArea.getText() +
            "--------------------------------------------------------------------------" + 
                    "-----------------------\n" +
            "           Press CHECK for errors or new versions before play " + "\n" +
            "--------------------------------------------------------------------------" + 
                    "-----------------------\n");
        }
    }//GEN-LAST:event_informationButtonActionPerformed

    private void configurationButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_configurationButtonActionPerformed
        // TODO add your handling code here:
        Show_UI showUI = new Show_UI (information);
        showUI.setVisible(true);
    }//GEN-LAST:event_configurationButtonActionPerformed

    /**
    * @param args the command line arguments
    */
    public static void main(String args[]) {
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new LoL_assembly_UI().setVisible(true);
            }
        });
    }


    /*
    public void windowClosing(WindowEvent event) {
        System.exit(0);
    }
     *
     */

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton aboutButton;
    private javax.swing.JButton checkButton;
    private javax.swing.JButton configurationButton;
    private javax.swing.JButton exitButton;
    private javax.swing.JButton informationButton;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JButton licenseButton;
    private javax.swing.JTextArea mainTextArea;
    private javax.swing.JButton modifyButton;
    private javax.swing.JButton normalButton;
    private javax.swing.JButton rankedButton;
    private javax.swing.JButton updateButton;
    // End of variables declaration//GEN-END:variables

}
